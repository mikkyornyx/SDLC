# SDLC library of security controls, practices and process steps
| - | - | - | - | - |

| Name  | Description | Phase | Type | Function |
| ------------- | ------------- | ------------- | ------------- | ------------- |
| Process stage  | Process step references standard process alignment and activities that are required to kickstart an initiative.  | Plan | Administrative | Preventive |
| Idea  | Idea step references start of activity. Depending on Enterprise Architecture steps definition, it can be named differently.  | Plan | Administrative |  |
| Feature definition  | In the feature definition step business defines which features and security requirements product needs to have and align to. This step is an input to Design and Architecture.  | Plan | Technical |  |
| Architecture  | This step maps overall Architecture guidelines to future product, including which technologies to use, how to fit future product into organization portfolio, align it with Enterprise Architecture and practices used in the organization.  | Plan | Technical | Preventive |
| Compliance & Risk assessment  | Compliance & Risk assessment is an initial control step for process alignment. This step is needed to validate that future product will stay within compliance frame and that all risks that will be associated with it will stay within risk appetite. This step can also mandate and drive particular Design decisions. Third party and future Supplier Chain Management alignment with requirements also happens in this step.  | Plan | Administrative | Preventive |
| Design  | Design step takes Architecture as an input and creates product detailed design according to industry best practices. Output Design should be detailed enough for Threat Modelling evaluation.  | Plan | Technical | Preventive |
| Threat modelling  | Threat modelling along with Design, Compliance & Risk assessment and Architecture phases is residing in the recurrent "bubble". Threat modelling is a security process which identifies, categorizes and analyzes threats and vulnerabilities applicable for the product (application) being built. Output of this step is an actual model - design/diagram of the system, list of threats and controls for mitigation. There are multiple methodologies available for threat modelling, overall idea of this step is to identify gaps and also places where applicable countermeasures have greatest effect. In case it is not possible to mitigate risks to tolerable extent, Design and/or Architecture need to be fixed. In a way, Threat Modelling is a control gate of Planning phase.  | Plan | Technical | Preventive |
| CI/CD pipeline design | CI/CD pipeline design is an initial design of SDLC and related pipeline based on service Compliance Requirements, Threat Modelling, Design and other software requirements. | Plan | Administrative | Preventive |
| IDE SAST (Integrated Development Environment SAST) | IDE SAST is a simplified way to perform Static Application Security Testing in near real-time inside IDE. Most common and simple mistakes and security bugs will be identified early in the development process. This step can be circumvented as IDE SAST usually comes with a plugin that can be overridden, also it does not perform full-scale SAST test. SAST is considered to be White-Box testing technique, where entire source code is available for automated review. | Develop | Technical | Detective |
| IDE SCA (Integrated Development Environment SCA) | IDE Software Composition Analysis is yet again quick way to identify potential problems with both internal and external components that will be used later in the build process. This step can identify potential problems with outdated, vulnerable or blacklisted components (due to license restrictions, for example). This step can also be circumvented as it resides in IDE usually as a plugin. However, having such helper early in the process before commits and unit tests allows for faster fixes in software composition and choice of secure components. | Develop | Technical | Detective |
| Unit test | Code gets covered with unit tests that may include early security testing and controls verification, including security unit tests, regressions testing, specific abuse cases and business logic flaw tests. At this point, test can sometimes still be done using white-box approach, depending on application. | Develop | Technical | Detective |
| Pre-commit hooks | Pre-commit hooks as a chain of automated code checks can help code stay within prescribed boundaries and align with various organization-specific requirements. For example, pre-commit hooks can check whether code is covered with comments, test cases, specific notation requirements, etc. so that it will pass further validation steps in the pipeline. | Develop | Technical | Detective |
| Secrets scanning | Secrets scanning step is a control gate that happens before commit and can be related to pre-commit hooks (or be one of the pre-commit hooks). Goal of this step is to ensure that code being committed to repository outside development IDE does not contain any sensitive data - production tokens, secrets etc. Secrets scanning is usually done using plugin or simple regex rules that look for specific patterns in the code. | Develop | Technical | Detective |
| Commit | Commit is a straightforward step of transferring code securely into repository from the IDE. | Develop | Technical |  |
| Sign | For integrity and non-repudiation purposes, commit can be signed by a digital signature. This way, each commit can be tracked and it's integrity can be checked at any point of time. Existence of a valid signature is later checked in the pipeline and is a prerequisite to start rigorous security testing and builds. | Develop | Technical | Preventive |
| Code Quality & Metrics | Code Quality & Metrics step can be done in SAST tool, it checks for various parameters, including tests coverage, code reusability, code alignment to standards, number of bugs, mistakes and vulnerabilities and so on. This step produces valuable output that can be later used, for example, in focused education of problematic areas. | Build & Test | Administrative | Detective |
| Signature check | Signature check steps checks for existence of valid commit signature and code integrity in the commit repository. | Build & Test | Technical | Detective |
| SCA (Software Composition Analysis) | Software Composition Analysis step that is performed outside development IDE and checks for same things - whether referenced packages are vulnerable or not, what is their patch level, are they supported, does their licensing scheme suit enterprise. This SCA is a tollgate - step if fully automated and results from this check can be used by CI orchestrator to whether move on with the pipeline or break the process and fix the code. | Build & Test | Technical | Detective |
| SAST (Static Application Security Testing) | This is the same SAST testing, but more rigorous and automated. White-box test that can find out and identify bugs, vulnerabilities and alignment of the code to certain guidelines. SAST is a first security test that performs "code review" in automated fashion. It can also be a tollgate - depending of the configuration of the CI orchestrator it is possible to define a threshold or tolerable level of code quality for build to pass along the pipeline. | Build & Test | Technical | Detective |
| Peer Review | Peer review is a manual step in the process. Goal of peer review is to have a second pair of eyes to check that code is composed as it should be, all previous necessary steps were done and code is ready to be built. Peer review can identify some business flaws, twisted convoluted injections and vulnerabilities etc. | Build & Test | Technical | Detective |
| Accept | Accept step is a formal acceptance that ends up peer review in case it was successful. It can be in a form of merging code to main branch. | Build & Test | Administrative |  |
| Sign | After peer review acceptance, code is signed once again using signature of reviewer. In a later stages of the pipeline, two signatures are needed and validated. This indicates that code was formally reviewed and approved and ensures integrity and non-repudiation throughout the pipeline. | Build & Test | Technical | Preventive |
| Package | Code packaging is a step where written software gets assembled/compiled/packaged for further testing and deployment, depending on target platform and its architecture. For some particular packages, additional dependencies from artifact repositories get embedded. | Release & Test | Technical |  |
| Signature check | For packaging step to happen successfully, two signatures of both developer and code reviewer get validated. | Release & Test | Technical | Detective |
| Artifact repository | After software got packaged, it gets transferred/copied to artifact repository where it is securely stored for further deployment/reuse purposes. | Release & Test | Technical | Preventive |
| Versioning | Versioning step helps to keep track of different package versions of the same software. In case rollback or restore is needed, proper version is kept in artifact repository and allows to "restore in time" to a previously known good configuration. Each package can have multiple versions with different features. | Release & Test | Technical | Preventive |
| Deploy to Staging | For a Staging branch, deploy to staging means promoting package to become future version of production application/service. Rigorous security and other types of testing are ahead. | Release & Test | Technical |  |
| Integration testing | Functional testing is a step where application is validated against functional requirements and specifications. Normally, mainline functions, usability, accessibility and error handling are tested here. Testing is usually executed against known test cases and results are compared to expected ones.  | Release & Test | Technical | Detective |
| Functional testing | During the Integration testing, application is tested against other systems it needs to communicate with, also in case application is part of larger suite, interoperability between different components is tested during this phase. API interoperability testing is part of integration test. Integration & Functional testing are normally Black-box tests. | Release & Test | Technical | Detective |
| Regression test | Regression test can be seen as a step, where delta (minor) changes to application land - there is no reason to re-run entire pipeline synchronously in case only minor changes are introduced, rather regression testing is an entry point, where concrete tests are selected to check changed code. Regression test can also include test cases against previously found bugs to ensure they don't make they way into upcoming releases. For example, if there are multiple code branches and some of them contain bugs which aren't fixed in the branch, copying that branch or code parts will also introduce same bugs into the pipeline. Regression testing is performed as Black-box test. | Release & Test | Technical | Detective |
| DAST (Dynamic Application Security Testing) | Dynamic Application Security Testing is a Black box testing technique, where multiple tests are performed against working application and its interfaces. Formally, this security testing includes negative testing with unwanted input, fuzzing, various overflows, injections and so on. DAST is able to identify most common security misconfigurations and bugs in the code. DAST can also be referred to automated security verification test. | Release & Test | Technical | Detective |
| IAST (Interactive Application Security Testing) | Interactive Application Security Testing goes beyond DAST capabilities and injects program module or code into running application. IAST provides more capabilities for running similar checks that DAST performs and in addition to standard application interfaces can submit input directly into program routines, co-routines and modules. IAST is able to diagnose application in runtime and identify problematic lines of code. | Release & Test | Technical | Detective |
| Vulnerability testing | Vulnerability testing is applicable for the platform that will host future application in both staging and production environments. Goal of this step is to ensure that environment is set up correctly and that underlying OS or platform does not contain known vulnerabilities. This step should normally be fully-automated. | Release & Test | Technical | Detective |
| Configuration compliance | Configuration compliance is a step that refers to configuration hardening - it analyzes future environment/platform that application will be hosted on and compares it to best practice benchmarks (such as CIS) and compliance requirements. This step should normally be fully-automated. | Release & Test | Technical | Detective |
| Penetration testing | Penetration testing or formal manual Security Verification is a manual step of identifying vulnerabilities and security misconfigurations related to running application/service. This step is performed by skilled individuals based on industry best practices and prior experience. | Release & Test | Technical | Detective |
| Architecture compliance | Architecture compliance step generally controls that overall solution or application architecture is aligned with common requirements (Enterprise Architecture frameworks and guidelines, architecture blueprints, components mandated for use in the project and so on). General infrastructure and overall alignment are also checked in this step. | Release & Test | Technical | Detective |
| Security review | Security review is optional step in case mandatory pipeline steps and requirements have been followed. This is an additional check (or, depending on the process, it can be mandatory), that controls that overall solution and security architecture are aligned with internal requirements and follow industry best practices. | Release & Test | Technical | Detective |
| - | - | - | - | - |








